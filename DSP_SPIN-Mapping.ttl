@prefix fn:           <http://www.w3.org/2005/xpath-functions#> .
@prefix sparql:       <http://www.w3.org/TR/2013/REC-sparql11-query-20130321/#> .
@prefix xsd:          <http://www.w3.org/2001/XMLSchema#> .
@prefix rdf:          <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs:         <http://www.w3.org/2000/01/rdf-schema#> .
@prefix owl:          <http://www.w3.org/2002/07/owl#> .
@prefix sp:           <http://spinrdf.org/sp#> .
@prefix spin:         <http://spinrdf.org/spin#> .
@prefix smf:          <http://topbraid.org/sparqlmotionfunctions#> .
@prefix spif:         <http://spinrdf.org/spif#> . 
@prefix spl:          <http://spinrdf.org/spl#> . 
@prefix spinx:        <http://spinrdf.org/spinx#> . 
@prefix owl2: 		  <http://constraints.org/owl2#> .
@prefix functions:    <http://www.example.org/functions#> .
@prefix templates:    <http://www.example.org/templates#> .
@prefix sparql:       <http://www.w3.org/TR/sparql11-query/#> .
@prefix a:            <http://www.example.org/OWL2InstanceData#> .
@prefix dsp:          <http://dublincore.org/dc-dsp#> .
@prefix dspFunctions: <http://dublincore.org/dc-dsp/functions#> .
@prefix dsp2spin:     <http://dublincore.org/dc-dsp/spin-mapping#> .

<constraints/owl> 
	a owl:Ontology ;
	rdfs:comment "" ;
	owl:imports <http://spinrdf.org/spl> ;
	owl:imports <http://www.w3.org/2005/xpath-functions> ;
	owl:versionInfo "0.0.1" .

	
# ---------------
# Description Templates


owl:Thing
	spin:constraint 
		# Identifier
		
		# Standalone
		[   a dsp2spin:DescriptionTemplates_Standalone ] ,
		
		# Minimum occurrence constraint
		[   a dsp:DescriptionTemplates_MinimumOccurrenceConstraint_1 ] ,
		
		# Maximum occurrence constraint
		[   a dsp:DescriptionTemplates_MaximumOccurrenceConstraint ] .
		
		# Resource Class Membership Constraint 
		
		
dsp:DescriptionTemplate
	spin:constraint 
		# Description Template - Minimum occurrence constraint
		[   a dsp:DescriptionTemplates_MinimumOccurrenceConstraint_2 ] ,
		# Statement Template - Minimum occurrence constraint
		[   a dsp:StatementTemplates_MinimumOccurrenceConstraint_2 ] .

# -----

# ---------------
# Statement Templates


owl:Thing
	spin:constraint 
		# Minimum occurrence constraint
		[   a dsp:StatementTemplates_MinimumOccurrenceConstraint_1 ] ,
		# Maximum occurrence constraint
		[   a dsp:StatementTemplates_MaximumOccurrenceConstraint ] .

#dsp:NonLiteralStatementTemplate
#	spin:constraint 
#		# Minimum occurrence constraint
#		[   a dsp:StatementTemplates_MinimumOccurrenceConstraint_2 ] .
		
#dsp:LiteralStatementTemplate
#	spin:constraint 
#		# Minimum occurrence constraint
#		[   a dsp:StatementTemplates_MinimumOccurrenceConstraint_2 ] .
		
# -----

# ---------------
# Property Constraints


owl:Thing
	spin:constraint 
		# Property List Constraint
		[   a dsp:PropertyConstraints_PropertyListConstraint ] .
		
# -----

# ---------------
# Literal Value Constraints


owl:Thing
	spin:constraint 
		# Literal List Constraint
		[   a dsp:LiteralValueConstraints_LiteralListConstraint ] ,
		# Literal Language Constraint
		[   a dsp:LiteralValueConstraints_LiteralLanguageConstraint_Mandatory ] ,
		[   a dsp:LiteralValueConstraints_LiteralLanguageConstraint_Disallowed ] ,
		# Literal Language List Constraint
		[   a dsp:LiteralValueConstraints_LiteralLanguageListConstraint ] ,
#		[   a dsp:LiteralValueConstraints_LiteralLanguageListConstraint_Testing ] ,
		# Syntax Encoding Scheme Constraint
#		[   a dsp:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_Mandatory ] ,
		# Syntax Encoding Scheme List Constraint
		[   a dsp:LiteralValueConstraints_SyntaxEncodingSchemeListConstraint ] .
		
# -----
	

	
	
		

# ---------------
# Description Templates - Identifier


# Summary: A string that can be used in a Value Constraint to reference a description template that applies to the value resource. 
# Allowed values: A valid XML ID string. 
# Default: N/A 

# --> RDF: resource URI
# --> no associated constraint 


# -----

# ---------------
# Description Templates - Standalone


# Summary: Whether descriptions matching this template are allowed to occur standalone, i.e. without being the value of a property. 
# Allowed values: "yes", "no", "both" 
# Default: "both" 
# Conditions:
# - If standalone is "yes", a matching description may not be a description of value occurring elsewhere in the DSP. [done]
# - If standalone is "no", a matching description *must* be a description of value occurring elsewhere in the DSP.
# - If standalone is "both", both are allowed. [done]
# - If this description template is referred to in a Value Constraint, standalone cannot be "yes". 

# --> constraint: standalone = no
# --> no constraints: standalone = yes, both

dsp2spin:DescriptionTemplates_Standalone_No
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           BIND ( ( datatype ( ?literal ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "literal" ] ] ] 
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           FILTER EXISTS { ?literalConstraint dsp:syntaxEncosingScheme ?ses . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "ses" ] ] ) ] ]

#           FILTER NOT EXISTS { ?literalConstraint dsp:syntaxEncosingScheme ?datatype . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "datatype" ] ] ) ] ]

#    		testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "violationMessage" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "literal: " ;
#					sp:arg2 [ sp:varName "literal" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " )" ] ] ) ].

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax encoding schemes ( " ;
					sp:arg2 [ sp:varName "datatype" ] ;
					sp:arg3 " ) not allowed for the literal ( " ;
					sp:arg4 [ sp:varName "literal" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Description Templates- Minimum Occurrence Constraint


# Summary: The minimum number of times this kind of description must appear in the Description Set. [done]
# Allowed values: non-negative integer
# Default: 0
# Conditions: must be equal or less than the Maximum occurrence [done]

# The minimum number of times this kind of description must appear in the Description Set. 
# -----
dsp:DescriptionTemplates_MinimumOccurrenceConstraint_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:minOccur ?minOccurDescription .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurDescription" ] ]
				
#	    	cardinalityDescription < minOccurDescription
#	    	-----
#	    	BIND ( ( dspFunctions:cardinalityDescription ( resourceClass ) ) AS ?cardinalityDescription ) . }
#			FILTER ( cardinalityDescription < ?minOccurDescription ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityDescription" ] ;
				sp:expression [
					a dspFunctions:cardinalityDescription ;
					sp:arg1 [ sp:varName "resourceClass" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "cardinalityDescription" ] ;
					sp:arg2 [ sp:varName "minOccurDescription" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality description ( " ;
					sp:arg2 [ sp:varName "cardinalityDescription" ] ;
					sp:arg3 ") < minOccur description ( " ;
					sp:arg4 [ sp:varName "minOccurDescription" ] ;
					sp:arg5 " )" ] ] ) ].
					
# dsp:minOccur <= dsp:maxOccur
# -----
dsp:DescriptionTemplates_MinimumOccurrenceConstraint_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {		
#           ?this dsp:minOccur ?minOccurDescription .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurDescription" ] ]
				
#           ?this dsp:maxOccur ?maxOccurDescription .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurDescription" ] ]
				
#			FILTER ( ?minOccurDescription > ?maxOccurDescription ) .
#           -----	   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "minOccurDescription" ] ;
					sp:arg2 [ sp:varName "maxOccurDescription" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "minOccur description ( " ;
					sp:arg2 [ sp:varName "minOccurDescription" ] ;
					sp:arg3 " ) > maxOccur description ( " ;
					sp:arg4 [ sp:varName "maxOccurDescription" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Description Templates - Maximum occurrence constraint


# Summary: The maximum number of times this kind of description is allowed to appear in the Description Set. [done]
# Allowed values: non-negative integer or "infinity" 
# Default: "infinity"
# Conditions: must be equal or greater than the Minimum occurrence [done]

# The maximum number of times this kind of description is allowed to appear in the Description Set. 
# -----
dsp:DescriptionTemplates_MaximumOccurrenceConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:minOccur ?maxOccurDescription .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurDescription" ] ]
				
#	    	cardinalityDescription > maxOccurDescription
#	    	-----
#	    	BIND ( ( dspFunctions:cardinalityDescription ( resourceClass ) ) AS ?cardinalityDescription ) . }
#			FILTER ( cardinalityDescription > ?maxOccurDescription ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityDescription" ] ;
				sp:expression [
					a dspFunctions:cardinalityDescription ;
					sp:arg1 [ sp:varName "resourceClass" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "cardinalityDescription" ] ;
					sp:arg2 [ sp:varName "maxOccurDescription" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality description ( " ;
					sp:arg2 [ sp:varName "cardinalityDescription" ] ;
					sp:arg3 ") < maxOccur description ( " ;
					sp:arg4 [ sp:varName "maxOccurDescription" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Description Templates - Resource Class Membership Constraint


# Summary: Classes that the resource may be an instance of 
# Allowed values: a list of class URIs 
# Default: no constraint 
# Conditions: if given, the resource must be an instance of one of the given classes. 

# -----


# -----

# ---------------
# Statement Templates - Minimum occurrence constraint


# Summary: The minimum number of times this kind of statement must appear in the enclosing Description. 
# Allowed values non-negative integer [todo]
# Default: 0 [todo]
# Conditions: must be equal or less than the Maximum occurrence 

# The minimum number of times this kind of statement must appear in the enclosing Description. 
# -----
dsp:StatementTemplates_MinimumOccurrenceConstraint_1
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:minOccur ?minOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurStatement" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#	    	cardinalityStatement < minOccurStatement
#	    	-----
#	    	BIND ( ( spl:objectCount ( ?this, ?property ) ) AS ?cardinalityStatement ) . }
#			FILTER ( cardinalityStatement < ?minOccurStatement ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityStatement" ] ;
				sp:expression [
					a spl:objectCount ;
					sp:arg1 [ sp:varName "this" ] ;
					sp:arg2 [ sp:varName "property" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:lt;
				    sp:arg1 [ sp:varName "cardinalityStatement" ] ;
					sp:arg2 [ sp:varName "minOccurStatement" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality statement ( " ;
					sp:arg2 [ sp:varName "cardinalityStatement" ] ;
					sp:arg3 " ) < minOccur statement ( " ;
					sp:arg4 [ sp:varName "minOccurStatement" ] ;
					sp:arg5 " )" ] ] ) ].			

# dsp:minOccur <= dsp:maxOccur
# -----
dsp:StatementTemplates_MinimumOccurrenceConstraint_2
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#		    ?this rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?this dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:minOccur ?minOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:minOccur ;
				sp:object [ sp:varName "minOccurStatement" ] ]
				
#           ?statementTemplate dsp:maxOccur ?maxOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurStatement" ] ]
				
#			FILTER ( ?minOccurStatement > ?maxOccurStatement ) .
#           -----	    
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "minOccurStatement" ] ;
					sp:arg2 [ sp:varName "maxOccurStatement" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "minOccur statement ( " ;
					sp:arg2 [ sp:varName "minOccurStatement" ] ;
					sp:arg3 " ) > maxOccur statement ( " ;
					sp:arg4 [ sp:varName "maxOccurStatement" ] ;
					sp:arg5 " )" ] ] ) ].
					
# -----

# ---------------
# Statement Templates - Maximum occurrence constraint


# Summary: The maximum number of times this kind of statement is allowed to appear in the enclosing Description. 
# Allowed values: non-negative integer or "infinity" [todo]
# Default: "infinity" [todo]
# Conditions: must be equal or greater than the Minimum occurrence  

# The maximum number of times this kind of statement is allowed to appear in the enclosing Description. 
# -----
dsp:StatementTemplates_MaximumOccurrenceConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#           ?statementTemplate dsp:maxOccur ?maxOccurStatement .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:maxOccur ;
				sp:object [ sp:varName "maxOccurStatement" ] ]
				
#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#	    	cardinalityStatement > maxOccurStatement
#	    	-----
#	    	BIND ( ( spl:objectCount ( ?this, ?property ) ) AS ?cardinalityStatement ) . }
#			FILTER ( cardinalityStatement > ?maxOccurStatement ) .
	
            [   a sp:Bind;
				sp:variable [ sp:varName "cardinalityStatement" ] ;
				sp:expression [
					a spl:objectCount ;
					sp:arg1 [ sp:varName "this" ] ;
					sp:arg2 [ sp:varName "property" ] ] ]     
			[   a sp:Filter ;
				sp:expression [ 
					a sp:gt;
				    sp:arg1 [ sp:varName "cardinalityStatement" ] ;
					sp:arg2 [ sp:varName "maxOccurStatement" ] ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "cardinality statement ( " ;
					sp:arg2 [ sp:varName "cardinalityStatement" ] ;
					sp:arg3 " ) < maxOccur statement ( " ;
					sp:arg4 [ sp:varName "maxOccurStatement" ] ;
					sp:arg5 " )" ] ] ) ].
					
# -----

# ---------------
# Statement Templates - Type Constraint


# Summary: The type of value surrogate (literal/non-literal) that is allowed in this Statement. 
# Allowed values: "literal" / "nonliteral" 
# Default: both allowed
# Conditions: If no value is given, no further constraining on the value surrogate can be made. 

# --> In RDF, dsp:NonLiteralStatementTemplate and dsp:LiteralStatementTemplate can be stated as types of statement templates.
# --> There is no constraint in RDF

# -----

# ---------------
# Property Constraints - Property List Constraint


# Summary: A set of properties that are allowed in this statement template. [done]
# Allowed values: a list of property URIs [done]
# Default: N/A [done]
# Conditions: cannot occur together with a sub-property constraint [todo]

# -----
dsp:PropertyConstraints_PropertyListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?object .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "object" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]
				
#			FILTER NOT EXISTS { ?statementTemplate dsp:property ?property . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "statementTemplate" ] ;
                            sp:predicate dsp:property ;
                            sp:object [ sp:varName "property" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "property ( " ;
					sp:arg2 [ sp:varName "property" ] ;
					sp:arg3 " not allowed for description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Property Constraints - Sub-Property Constraint


# Summary: Only sub-properties of the given property are allowed in this statement template.  
# Note that the given property is included in this list (all properties are sub-properties of themselves). 
# Allowed values: a property URI 
# Default: N/A 
# Conditions: cannot occur together with a property list constraint 

# -----


# -----

# ---------------
# Literal Value Constraints - Literal List Constraint [done]


# Literals that are allowed as values:
# Allowed values: list of literals, i.e. (string, language tag) or (string, syntax encoding scheme URI) pairs. 

# -----
dsp:LiteralValueConstraints_LiteralListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#			FILTER NOT EXISTS { ?literalConstraint dsp:literal ?literal }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:literal ;
                            sp:object [ sp:varName "literal" ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "literal ( " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 " not allowed for description template ( " ;
					sp:arg4 [ sp:varName "descriptionTemplate" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Literal Language Constraint


# Summary: Whether languages are allowed for the literal [done]
# Allowed values: mandatory, optional, disallowed [done]
# Default: optional [done]
# Conditions: if "mandatory", Syntax encoding schemes are automatically disallowed 

# 
# -----
dsp:LiteralValueConstraints_LiteralLanguageConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#			FILTER ( ?language = "" ) .
#           -----   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:eq;
				    sp:arg1 [ sp:varName "language" ] ;
					sp:arg2 "" ] ]	

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "language mandatory for literal ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "')" ] ] ) ].
					
dsp:LiteralValueConstraints_LiteralLanguageConstraint_Disallowed
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:languageOccurrence ?languageOccurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:languageOccurrence ;
				sp:object "disallowed"^^dsp:occurrence ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
					
#			FILTER ( ?language != "" ) .
#           -----   
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "language" ] ;
					sp:arg2 "" ] ]	

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "languages not allowed for literal ( '" ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 "'@" ;
					sp:arg4 [ sp:varName "language" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# --------------
# Literal Value Constraints - Literal Language List Constraint [done]


# Summary: languages allowed for the literal 
# Allowed values: a list consisting of language tags 
# Default: no constraint  

# 
# -----
dsp:LiteralValueConstraints_LiteralLanguageListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#           -----
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 
	
#           FILTER EXISTS { ?literalConstraint dsp:language ?languageDef . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "languageDef" ] ] ) ] ]

#           FILTER NOT EXISTS { 
#               ?literalConstraint dsp:language ?languageDefinition . 
#               BIND( ( IF( ?language^^xsd:string = ?languageDefinition^^xsd:string, "true"^^xsd:boolean, "false"^^xsd:boolean ) ) AS ?match ) .
#               FILTER ( ?match = "true"^^xsd:boolean ) . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:language ;
                            sp:object [ sp:varName "languageDefinition" ] ] 	
						[   a sp:Bind ;
							sp:expression [
								a sp:if ;
								sp:arg1 [ 
									a sp:eq ;
									sp:arg1 [ sp:varName "language"^^xsd:string ] ;
									sp:arg2 [ sp:varName "languageDefinition"^^xsd:string ] ] ;
								sp:arg2 "true"^^xsd:boolean ;
								sp:arg3 "false"^^xsd:boolean ] ;
							sp:variable [ sp:varName "match"^^xsd:boolean ] ] 
						[   a sp:Filter ;
							sp:expression [ 
								a sp:eq ;
								sp:arg1 [ sp:varName "match"^^xsd:boolean ] ;
								sp:arg2 "true"^^xsd:boolean ] ] ) ] ]

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
				[   a sp:Bind;
					sp:variable [ sp:varName "violationMessage" ];
					sp:expression [ 
						a fn:concat; 
						sp:arg1 "The language ( " ;
						sp:arg2 [ sp:varName "language" ] ;
						sp:arg3 " ) is not allowed for the literal ( " ;
						sp:arg4 [ sp:varName "literal" ] ;
						sp:arg5 " )" ] ] ) ].
					
dsp:LiteralValueConstraints_LiteralLanguageListConstraint_Testing
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]

#           BIND ( ( lang ( ?literal ) ) AS ?language ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "language" ];
				sp:expression [
					a sp:lang;
					sp:arg1 [ sp:varName "literal" ] ] ] 

#           testing
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDatatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "language" ] ] ] 
			[   sp:subject [ sp:varName "literalConstraint" ] ;
				sp:predicate dsp:language ;
				sp:object [ sp:varName "languageDefinition" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDefinitionDatatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "languageDefinition" ] ] ] 
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDefinitionStr" ];
				sp:expression [
					a sp:str;
					sp:arg1 [ sp:varName "languageDefinition" ] ] ] 
			[   a sp:Bind;
				sp:variable [ sp:varName "languageDefinitionStrDatatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "languageDefinitionStr" ] ] ] 	
			[   a sp:Bind ;
                sp:expression [
					a sp:if ;
                    sp:arg1 [ 
						a sp:eq ;
						sp:arg1 [ sp:varName "language"^^xsd:string ] ;
						sp:arg2 [ sp:varName "languageDefinitionStr"^^xsd:string ] ] ;
                    sp:arg2 "true"^^xsd:boolean ;
                    sp:arg3 "false"^^xsd:boolean ] ;
                sp:variable [ sp:varName "match"^^xsd:boolean ] ] 
#			-----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "literal: " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 " | language: " ;
					sp:arg4 [ sp:varName "language" ] ;
					sp:arg5 " | datatype (language): " ;
					sp:arg6 [ sp:varName "languageDatatype" ] ;
					sp:arg7 " | language definition: " ;
					sp:arg8 [ sp:varName "languageDefinition" ] ;
					sp:arg9 " | datatype (language definition): " ;
					sp:arg10 [ sp:varName "languageDefinitionDatatype" ] ;
					sp:arg11 " | str (language definition): " ;
					sp:arg12 [ sp:varName "languageDefinitionStr" ] ;
					sp:arg13 " | datatype (str (language definition)): " ;
					sp:arg14 [ sp:varName "languageDefinitionStrDatatype" ] ;
					sp:arg15 " | match: " ;
					sp:arg16 [ sp:varName "match" ] ;
					sp:arg17 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Syntax Encoding Scheme Constraint


# Summary: Whether Syntax Encoding Schemes are allowed for the literal 
# Allowed values: mandatory, optional, disallowed 
# Default: optional
# Conditions: if "mandatory", language tags are automatically disallowed. [todo]

# limitations
# - If there is no datatype IRI and no language tag, the datatype is xsd:string
# - If there is a language tag, the datatype is rdf:langString

# 
# -----
dsp:LiteralValueConstraints_SyntaxEncodingSchemeConstraint_Mandatory
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
#			[   sp:subject [ sp:varName "this" ] ;
#			    sp:predicate [ sp:varName "property" ] ;
#				sp:object [ sp:varName "literal" ] ]
				
#           FILTER ( ?property != rdf:type ) .
#			[   a sp:Filter ;
#				sp:expression [ 
#					a sp:ne;
#				    sp:arg1 [ sp:varName "property" ] ;
#					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           ?literalConstraint dsp:syntaxEncodingSchemeOccurrence "mandatory"^^dsp:occurrence .
#           -----
			[   sp:subject [ sp:varName "literalConstraint" ] ;
			    sp:predicate dsp:syntaxEncodingSchemeOccurrence ;
				sp:object "mandatory"^^dsp:occurrence ]

#           FILTER EXISTS { 
#               ?this ?property ?literal .
#               BIND ( ( datatype ( ?literal ) ) AS ?datatype ) . 
#               FILTER ( ?datatype = "" ) . } .
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
					    [   sp:subject [ sp:varName "this" ] ;
                            sp:predicate [ sp:varName "property" ] ;
                            sp:object [ sp:varName "literal" ] ]
						[   a sp:Bind;
							sp:variable [ sp:varName "datatype" ];
							sp:expression [
								a sp:datatype;
								sp:arg1 [ sp:varName "literal" ] ] ] 
#						[   a sp:Filter ;
#							sp:expression [ 
#								a sp:eq;
#								sp:arg1 [ sp:varName "datatype" ] ;
#								sp:arg2 "" ] ]
					) ] ]

#    		testing
#           -----
			[   sp:subject [ sp:varName "this" ] ;
				sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "literal" ] ] ]
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "literal: " ;
					sp:arg2 [ sp:varName "literal" ] ;
					sp:arg3 " | datatype: " ;
					sp:arg4 [ sp:varName "datatype" ] ;
					sp:arg5 " )" ] ] ) ].

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "violationMessage" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "languages not allowed for literal ( '" ;
#					sp:arg2 [ sp:varName "literal" ] ;
#					sp:arg3 "'@" ;
#					sp:arg4 [ sp:varName "language" ] ;
#					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Literal Value Constraints - Syntax Encoding Scheme List Constraint [done]


# Summary: Syntax encoding schemes allowed for the literal 
# Allowed values: a list consisting of syntax encoding scheme URIs 
# Default: no constraint 


dsp:LiteralValueConstraints_SyntaxEncodingSchemeListConstraint
	a spin:Template; 
	rdfs:subClassOf spin:Templates ;
	spin:labelTemplate "" ;
	rdfs:label "" ;
	rdfs:comment "" ;
	spin:body [
		a sp:Construct ;
#	    CONSTRUCT {
#		    _:violation 
#			    a spin:ConstraintViolation ;
#				rdfs:label ?violationMessage ;
#			    spin:violationRoot ?this ;
#			    spin:violationPath ?propertyPath ;
#				spin:violationSource ?violationSource }
		sp:templates ( 
			[   sp:subject _:violation ;
				sp:predicate rdf:type ;
				sp:object spin:ConstraintViolation ]
			[   sp:subject _:violation ; 
				sp:predicate rdfs:label ;
				sp:object [ sp:varName "violationMessage" ] ] 
			[	sp:subject _:violation ;
				sp:predicate spin:violationRoot ;
				sp:object spin:_this ]		 
			[   sp:subject _:violation ;
				sp:predicate spin:violationPath ;
				sp:object [ sp:varName "violationPath" ] ] 
			[   sp:subject _:violation ;
				sp:predicate spin:violationSource ;
				sp:object [ sp:varName "violationSource" ] ] ) ;
		sp:where ( 
#		WHERE {	
#           ?this rdf:type ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate rdf:type ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?this ?property ?literal .
#           -----
			[   sp:subject [ sp:varName "this" ] ;
			    sp:predicate [ sp:varName "property" ] ;
				sp:object [ sp:varName "literal" ] ]
				
#           BIND ( ( datatype ( ?literal ) ) AS ?datatype ) . 
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "datatype" ];
				sp:expression [
					a sp:datatype;
					sp:arg1 [ sp:varName "literal" ] ] ] 
				
#           FILTER ( ?property != rdf:type ) .
			[   a sp:Filter ;
				sp:expression [ 
					a sp:ne;
				    sp:arg1 [ sp:varName "property" ] ;
					sp:arg2 rdf:type ] ]
				
#		    ?descriptionTemplate rdf:type dsp:DescriptionTemplate .
#           -----
            [   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate rdf:type ;
				sp:object dsp:DescriptionTemplate ]
				
#           ?descriptionTemplate dsp:resourceClass ?resourceClass .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:resourceClass ;
				sp:object [ sp:varName "resourceClass" ] ]
				
#           ?descriptionTemplate dsp:statementTemplate ?statementTemplate .
#           -----
			[   sp:subject [ sp:varName "descriptionTemplate" ] ;
			    sp:predicate dsp:statementTemplate ;
				sp:object [ sp:varName "statementTemplate" ] ]

#           ?statementTemplate dsp:property ?property .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:property ;
				sp:object [ sp:varName "property" ] ]
				
#           ?statementTemplate dsp:literalConstraint ?literalConstraint .
#           -----
			[   sp:subject [ sp:varName "statementTemplate" ] ;
			    sp:predicate dsp:literalConstraint ;
				sp:object [ sp:varName "literalConstraint" ] ]
				
#           FILTER EXISTS { ?literalConstraint dsp:syntaxEncosingScheme ?ses . }
#           -----	
			[   a sp:Filter ;
                sp:expression [ 
					a sp:exists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "ses" ] ] ) ] ]

#           FILTER NOT EXISTS { ?literalConstraint dsp:syntaxEncosingScheme ?datatype . }
#           -----
			[   a sp:Filter ;
                sp:expression [ 
					a sp:notExists ;
                    sp:elements ( 
						[   sp:subject [ sp:varName "literalConstraint" ] ;
                            sp:predicate dsp:syntaxEncodingScheme ;
                            sp:object [ sp:varName "datatype" ] ] ) ] ]

#    		testing
#           -----
#			[   a sp:Bind;
#				sp:variable [ sp:varName "violationMessage" ];
#				sp:expression [ 
#					a fn:concat; 
#					sp:arg1 "literal: " ;
#					sp:arg2 [ sp:varName "literal" ] ;
#					sp:arg3 " | datatype: " ;
#					sp:arg4 [ sp:varName "datatype" ] ;
#					sp:arg5 " )" ] ] ) ].

#    		BIND ( ... ) AS ?violationMessage ) . }
#           -----
			[   a sp:Bind;
				sp:variable [ sp:varName "violationMessage" ];
				sp:expression [ 
					a fn:concat; 
					sp:arg1 "Syntax encoding schemes ( " ;
					sp:arg2 [ sp:varName "datatype" ] ;
					sp:arg3 " ) not allowed for the literal ( " ;
					sp:arg4 [ sp:varName "literal" ] ;
					sp:arg5 " )" ] ] ) ].

# -----

# ---------------
# Non-Literal Value Constraints - Description Template Reference


# Summary: A reference to a description template that may be used to describe the value 
# Allowed values: an identifier defined in a Description Template 
# Default: Related description not allowed 
# Conditions: if given, any related description of the value within the record must match the referenced Description Template. 
#              If the referenced Description Template contains mandatory Statement templates, such a description of the value must exist. 

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Class Membership Constraint


# Summary: Classes that the value may be an instance of 
# Allowed values: a list of class URIs 
# Default: no constraint 
# Conditions: if given, the value must be an instance of one of the given classes.   

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Value URI Occurrence Constraint


# Summary: Whether a value URI must be given 
# Allowed values: "disallowed", "optional", "mandatory" 
# Default: "optional"  

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Value URI List Constraint


# Summary: URIs that are allowed as value URIs. 
# Allowed values: a list of URIs 
# Default: no constraint 
# Conditions: If a value URI is given, it must be taken from this list. Cannot be specified if value occurrence is "disallowed"  

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Vocabulary Encoding Scheme Occurrence Constraint


# Summary: Whether a vocabulary encoding scheme must be given 
# Allowed values: "disallowed", "optional", "mandatory" 
# Default: "optional" 

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Vocabulary Encoding Scheme List Constraint


# Summary: URIs that are allowed as Vocabulary Encoding schemes. 
# Allowed values: a list of URIs 
# Default: no constraint 
# Conditions: If a vocabulary encoding scheme is given, it must be taken from this list. Cannot be specified if vocabulary encoding scheme occurrence is "disallowed"

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Minimum Occurrence Constraint


# Summary: The minimum number of times this kind of value string must appear in the enclosing Statement. 
# Allowed values: non-negative integer 
# Default: 0 
# Conditions: must be equal or less than the Maximum occurrence 

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - Maximum Occurrence Constraint


# Summary: The maximum number of times this kind of value string is allowed to appear in the enclosing Statement. 
# Allowed values: non-negative integer or "infinity" 
# Default: "infinity" 
# Conditions: must be equal or greater than the Minimum occurrence 

# 
# -----


# -----

# ---------------
# Non-Literal Value Constraints - All Literal value constraints (section 6.5) can be used for value strings as well. 


# 

# 
# -----


# -----